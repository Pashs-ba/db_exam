Главная проблема - возможность встать в тупик, из за того что процессы не могут договориться об использовании ресурсов

есть 2 красивые иллюстрации к этой проблеме
# Философы на обеде
Есть круглый стол, за ним 5 философов и 5 вилок, каждому нужно взять минимум 2.
Если философы не сильно синхронизировались то проблем нет, но если вдруг они начинают чего то хотеть синхронно то возникает проблемы:
## DeadLock
Каждый философ берет по одной вилке и ждет когда освободится другая - и все встали в классический тупик
## LiveLock
Почти как дедлок но интеретснее - снаружи кажется что все ратает, но внутри ничего не происходит.
Каждый философ берет вилку и проверяет состояние другой, если она занята, он на небольшое время отпускает первую
Собственно проблема та же - если все синхронно будут проверять, то ничего не выйдет

## Рандом
Щепотка случая и все заробит, если повезет + есть накладные расходы

## Официант
ОС может помочь философам синхронизировать выбор

# Читатели и писатели
![[Pasted image 20240620121132.png]]

Проблема связана с чтением и записью в некоторый ресурс, очевидно, что читать можно многопоточно, а записывать только когда никому данные не нужны, но может возникнуть проблема как на рисунке.
Решение: Делаем очередь по времени, там находим первый запрос на запись, рассспаралеливаем все чтения до него и потом записываем. Повторить пока очередь не опустеет
Это будет плохо рабоать если запросы на чтение и запись чередуются. Поэтому можно группировать запросы на чтение, что конечно вызовет неконсистентность, но зато уменьшит время работы.