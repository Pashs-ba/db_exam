В каждом алгосе должен быть пролог - заявление о входе в критическую секцию, сама секция и эпилог - заявление о выходе.
Главная сложность - процессы не могут общаться между собой и вынужденны постоянно пологаться на структуры в ос, которые не всегда отражают актульный статус ресурса (ты зашел в туалет, снял штаны, и еще не закрыл защелку)

# Замок
```C++
shared int lock = 0;
F(){
	while(lock){} // wait
	lock = 1;
	// critical session
	lock = 0;
}
```
Главная проблема - в строчке после while - тут может случится прерывание и нарушение взаимоисключения

## Строгое чередование
```C++
shared int turn = 0;
F(){
	const my_turn = 1;
	while (turn != my_turn) {}
	// critical section
	turn = 1 - my_turn;
}
```
Проблема не-атомарного перехода решена, но теперь нет прогресса - процесс к которму перешла очередь может просто не использовать ее (например он спит)

## Флаги готовности
```c++
shared int flags[2] = {0, 0}
F(){
	flags[0] = 1;
	while (other_flags_up(flags)) {}
	// critical section
	flags[0] = 1;
}
```
Операция опять не атомарна и это приводит к тупику - несколько процессов успеют поднять флаг до того как войдут в ожидание

## Алгоритм Петерсона
Он же "очень вежливое чередование" - процесс заявлет о своем намеринии взять флаг, а потом ожидает пока все его "увааемые коллеги " ресурсом попользуются
```c++
shared int flags[2] = {0, 0}
shared int turn = 0;

F() {
	const my_turn = 1;
	flags[0] = 1;
	turn = 1 - my_turn;
	while (flags[1-my_turn] && turn == 1-my_turn) {}
	//critical section
	flags[1] = 0;
}
```
Нет никаких проблем с взимоисключением, тупиками и прогрессом.
Но для большого колличества процессов придется рил долго ждать и писать страшные условия.
А еще есть проблема с добавлением новых процессов